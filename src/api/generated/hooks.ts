/**
 * Generated by orval v6.12.1 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult
} from "react-query";
import { useInfiniteQuery, useMutation, useQuery } from "react-query";
import type { ErrorType } from "../mutator/custom-instance";
import { customInstance } from "../mutator/custom-instance";
import type {
  AlarmReq,
  AlarmUdtReq,
  BalanceRes,
  Blame200,
  BlameReq,
  BlameTypeList200,
  BlameTypeReq,
  BlameTypeUpdateReq,
  Board200,
  BoardDelete200,
  BoardDetail200,
  BoardLikeRequest,
  BoardLikeResponse,
  BoardReq,
  BoardUpdate200,
  Boards1200,
  Boards1Params,
  BoardsParams,
  BoardsRes,
  Categories200,
  CategoriesCount200,
  CategoryDeleteReq,
  CategoryInsertReq,
  CategoryUpdateReq,
  CommentLikeRequest,
  CommentLikeResponse,
  CommentReq,
  DeleteAlarm200,
  DeleteBalance200,
  DeleteCategory200,
  DeleteComment200,
  GetAllBalanceRes,
  GetCommentList1200,
  GetCommentList1Params,
  GetCommentList200,
  GetCommentListParams,
  GetPreviewBoards200,
  GetPreviewBoardsParams,
  GetWhereUserVote200,
  InsertAlarm200,
  InsertAlarmChk200,
  InsertBalance200,
  InsertBalanceReq,
  InsertBlameType1200,
  InsertBlameType200,
  InsertBlameType2200,
  InsertCategory200,
  InsertComment200,
  JoinReq,
  JoinRes,
  LoginReq,
  Oauth2Req,
  Oauth2Res,
  ProfileReq,
  UpdateAlarm200,
  UpdateBoardReq,
  UpdateCategory200,
  UpdateComment200,
  UpdateCommentParams,
  UserMbti,
  UserRes,
  UserSelfRes,
  VoteBalanceGame200,
  VoteBalanceReq
} from "./types";

// eslint-disable-next-line
type SecondParameter<T extends (...args: any) => any> = T extends (config: any, args: infer P) => any ? P : never;

/**
 * Í≤åÏãúÍ∏ÄÏùò idÎ•º ÌÜµÌï¥ ÎåìÍ∏Ä Î™©Î°ùÏùÑ Í∞ÄÏ†∏Ïò®Îã§.
 * @summary ÎåìÍ∏Ä Î™©Î°ù Ï°∞Ìöå
 */
export const getCommentList = (
  params: GetCommentListParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GetCommentList200>({ url: `/api/comments`, method: "get", params, signal }, options);
};

export const getGetCommentListQueryKey = (params: GetCommentListParams) => [
  `/api/comments`,
  ...(params ? [params] : [])
];

export type GetCommentListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCommentList>>>;
export type GetCommentListInfiniteQueryError = ErrorType<unknown>;

export const useGetCommentListInfinite = <
  TData = Awaited<ReturnType<typeof getCommentList>>,
  TError = ErrorType<unknown>
>(
  params: GetCommentListParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCommentList>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCommentListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCommentList>>> = ({ signal }) =>
    getCommentList(params, requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getCommentList>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetCommentListQueryResult = NonNullable<Awaited<ReturnType<typeof getCommentList>>>;
export type GetCommentListQueryError = ErrorType<unknown>;

export const useGetCommentList = <TData = Awaited<ReturnType<typeof getCommentList>>, TError = ErrorType<unknown>>(
  params: GetCommentListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getCommentList>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCommentListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCommentList>>> = ({ signal }) =>
    getCommentList(params, requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof getCommentList>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * ÎåìÍ∏ÄÏùò ÎÇ¥Ïö©ÏùÑ ÏàòÏ†ïÌïúÎã§.
 * @summary ÎåìÍ∏Ä ÎÇ¥Ïö© ÏàòÏ†ï
 */
export const updateComment = (params: UpdateCommentParams, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<UpdateComment200>({ url: `/api/comments`, method: "put", params }, options);
};

export type UpdateCommentMutationResult = NonNullable<Awaited<ReturnType<typeof updateComment>>>;

export type UpdateCommentMutationError = ErrorType<unknown>;

export const useUpdateComment = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateComment>>,
    TError,
    { params: UpdateCommentParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateComment>>, { params: UpdateCommentParams }> = (
    props
  ) => {
    const { params } = props ?? {};

    return updateComment(params, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof updateComment>>, TError, { params: UpdateCommentParams }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * ÎåìÍ∏ÄÏùÑ ÏÇΩÏûÖÌïúÎã§.
 * @summary ÎåìÍ∏Ä ÏÇΩÏûÖ
 */
export const insertComment = (commentReq: CommentReq, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<InsertComment200>(
    { url: `/api/comments`, method: "post", headers: { "Content-Type": "application/json" }, data: commentReq },
    options
  );
};

export type InsertCommentMutationResult = NonNullable<Awaited<ReturnType<typeof insertComment>>>;
export type InsertCommentMutationBody = CommentReq;
export type InsertCommentMutationError = ErrorType<unknown>;

export const useInsertComment = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof insertComment>>, TError, { data: CommentReq }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof insertComment>>, { data: CommentReq }> = (props) => {
    const { data } = props ?? {};

    return insertComment(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof insertComment>>, TError, { data: CommentReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò Î¶¨Ïä§Ìä∏Îßå Î∞òÌôòÌïúÎã§.
 * @summary Ïπ¥ÌÖåÍ≥†Î¶¨ Î™©Î°ù Ï°∞Ìöå
 */
export const categories = (options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
  return customInstance<Categories200>({ url: `/api/categories`, method: "get", signal }, options);
};

export const getCategoriesQueryKey = () => [`/api/categories`];

export type CategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof categories>>>;
export type CategoriesInfiniteQueryError = ErrorType<unknown>;

export const useCategoriesInfinite = <
  TData = Awaited<ReturnType<typeof categories>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof categories>>, TError, TData>;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCategoriesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof categories>>> = ({ signal }) =>
    categories(requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof categories>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type CategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof categories>>>;
export type CategoriesQueryError = ErrorType<unknown>;

export const useCategories = <TData = Awaited<ReturnType<typeof categories>>, TError = ErrorType<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof categories>>, TError, TData>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCategoriesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof categories>>> = ({ signal }) =>
    categories(requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof categories>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò Ïù¥Î¶ÑÏùÑ Î≥ÄÍ≤ΩÌïúÎã§.
 * @summary Ïπ¥ÌÖåÍ≥†Î¶¨ Î≥ÄÍ≤Ω
 */
export const updateCategory = (
  categoryUpdateReq: CategoryUpdateReq,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<UpdateCategory200>(
    { url: `/api/categories`, method: "put", headers: { "Content-Type": "application/json" }, data: categoryUpdateReq },
    options
  );
};

export type UpdateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof updateCategory>>>;
export type UpdateCategoryMutationBody = CategoryUpdateReq;
export type UpdateCategoryMutationError = ErrorType<unknown>;

export const useUpdateCategory = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCategory>>,
    TError,
    { data: CategoryUpdateReq },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCategory>>, { data: CategoryUpdateReq }> = (
    props
  ) => {
    const { data } = props ?? {};

    return updateCategory(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof updateCategory>>, TError, { data: CategoryUpdateReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * ÏÉàÎ°úÏö¥ Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÇΩÏûÖÌïúÎã§.
 * @summary Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÇΩÏûÖ
 */
export const insertCategory = (
  categoryInsertReq: CategoryInsertReq,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<InsertCategory200>(
    {
      url: `/api/categories`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: categoryInsertReq
    },
    options
  );
};

export type InsertCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof insertCategory>>>;
export type InsertCategoryMutationBody = CategoryInsertReq;
export type InsertCategoryMutationError = ErrorType<unknown>;

export const useInsertCategory = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof insertCategory>>,
    TError,
    { data: CategoryInsertReq },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof insertCategory>>, { data: CategoryInsertReq }> = (
    props
  ) => {
    const { data } = props ?? {};

    return insertCategory(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof insertCategory>>, TError, { data: CategoryInsertReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÇ≠Ï†úÌïúÎã§.
 * @summary Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÇ≠Ï†ú
 */
export const deleteCategory = (
  categoryDeleteReq: CategoryDeleteReq,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<DeleteCategory200>(
    {
      url: `/api/categories`,
      method: "delete",
      headers: { "Content-Type": "application/json" },
      data: categoryDeleteReq
    },
    options
  );
};

export type DeleteCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCategory>>>;
export type DeleteCategoryMutationBody = CategoryDeleteReq;
export type DeleteCategoryMutationError = ErrorType<unknown>;

export const useDeleteCategory = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCategory>>,
    TError,
    { data: CategoryDeleteReq },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCategory>>, { data: CategoryDeleteReq }> = (
    props
  ) => {
    const { data } = props ?? {};

    return deleteCategory(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof deleteCategory>>, TError, { data: CategoryDeleteReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Ï°∞Í±¥Ïóê Îî∞Îùº Í≤åÏãúÍ∏ÄÏùÑ Ï°∞ÌöåÌïúÎã§.http://localhost:8080/api/boards?categoryId=0&page=0&size=1&sort=id,DESC
 * @summary Í≤åÏãúÍ∏Ä Î™©Î°ù Ï°∞Ìöå
 */
export const boards1 = (
  params: Boards1Params,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<Boards1200>({ url: `/api/boards`, method: "get", params, signal }, options);
};

export const getBoards1QueryKey = (params: Boards1Params) => [`/api/boards`, ...(params ? [params] : [])];

export type Boards1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof boards1>>>;
export type Boards1InfiniteQueryError = ErrorType<unknown>;

export const useBoards1Infinite = <TData = Awaited<ReturnType<typeof boards1>>, TError = ErrorType<unknown>>(
  params: Boards1Params,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof boards1>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBoards1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof boards1>>> = ({ signal }) =>
    boards1(params, requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof boards1>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type Boards1QueryResult = NonNullable<Awaited<ReturnType<typeof boards1>>>;
export type Boards1QueryError = ErrorType<unknown>;

export const useBoards1 = <TData = Awaited<ReturnType<typeof boards1>>, TError = ErrorType<unknown>>(
  params: Boards1Params,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof boards1>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBoards1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof boards1>>> = ({ signal }) =>
    boards1(params, requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof boards1>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Í≤åÏãúÍ∏ÄÏùÑ ÏàòÏ†ïÌïúÎã§.
 * @summary Í≤åÏãúÍ∏Ä ÏàòÏ†ïÌïúÎã§
 */
export const boardUpdate = (updateBoardReq: UpdateBoardReq, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<BoardUpdate200>(
    { url: `/api/boards`, method: "put", headers: { "Content-Type": "application/json" }, data: updateBoardReq },
    options
  );
};

export type BoardUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof boardUpdate>>>;
export type BoardUpdateMutationBody = UpdateBoardReq;
export type BoardUpdateMutationError = ErrorType<unknown>;

export const useBoardUpdate = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof boardUpdate>>, TError, { data: UpdateBoardReq }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof boardUpdate>>, { data: UpdateBoardReq }> = (props) => {
    const { data } = props ?? {};

    return boardUpdate(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof boardUpdate>>, TError, { data: UpdateBoardReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * ÏÉàÎ°úÏö¥ Í≤åÏãúÍ∏ÄÏùÑ ÏÇΩÏûÖÌïúÎã§.
 * @summary Í≤åÏãúÍ∏Ä ÏÇΩÏûÖ
 */
export const board = (boardReq: BoardReq, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<Board200>(
    { url: `/api/boards`, method: "post", headers: { "Content-Type": "application/json" }, data: boardReq },
    options
  );
};

export type BoardMutationResult = NonNullable<Awaited<ReturnType<typeof board>>>;
export type BoardMutationBody = BoardReq;
export type BoardMutationError = ErrorType<unknown>;

export const useBoard = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof board>>, TError, { data: BoardReq }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof board>>, { data: BoardReq }> = (props) => {
    const { data } = props ?? {};

    return board(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof board>>, TError, { data: BoardReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Ïã†Í≥† Í∞ÄÎä•Ìïú Ï¢ÖÎ•òÎ•º ÎÇòÌÉÄÎÇ∏Îã§.
 * @summary Ïã†Í≥† Ï¢ÖÎ•ò
 */
export const blameTypeList = (options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
  return customInstance<BlameTypeList200>({ url: `/api/blame/type`, method: "get", signal }, options);
};

export const getBlameTypeListQueryKey = () => [`/api/blame/type`];

export type BlameTypeListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof blameTypeList>>>;
export type BlameTypeListInfiniteQueryError = ErrorType<unknown>;

export const useBlameTypeListInfinite = <
  TData = Awaited<ReturnType<typeof blameTypeList>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof blameTypeList>>, TError, TData>;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBlameTypeListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof blameTypeList>>> = ({ signal }) =>
    blameTypeList(requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof blameTypeList>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type BlameTypeListQueryResult = NonNullable<Awaited<ReturnType<typeof blameTypeList>>>;
export type BlameTypeListQueryError = ErrorType<unknown>;

export const useBlameTypeList = <
  TData = Awaited<ReturnType<typeof blameTypeList>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof blameTypeList>>, TError, TData>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBlameTypeListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof blameTypeList>>> = ({ signal }) =>
    blameTypeList(requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof blameTypeList>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Ïã†Í≥† Í∞ÄÎä•Ìïú Ï¢ÖÎ•òÎ•º ÏàòÏ†ïÌïúÎã§.
 * @summary Ïã†Í≥† Ï¢ÖÎ•ò ÏàòÏ†ï
 */
export const insertBlameType = (
  blameTypeUpdateReq: BlameTypeUpdateReq,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<InsertBlameType200>(
    {
      url: `/api/blame/type`,
      method: "put",
      headers: { "Content-Type": "application/json" },
      data: blameTypeUpdateReq
    },
    options
  );
};

export type InsertBlameTypeMutationResult = NonNullable<Awaited<ReturnType<typeof insertBlameType>>>;
export type InsertBlameTypeMutationBody = BlameTypeUpdateReq;
export type InsertBlameTypeMutationError = ErrorType<unknown>;

export const useInsertBlameType = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof insertBlameType>>,
    TError,
    { data: BlameTypeUpdateReq },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof insertBlameType>>, { data: BlameTypeUpdateReq }> = (
    props
  ) => {
    const { data } = props ?? {};

    return insertBlameType(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof insertBlameType>>, TError, { data: BlameTypeUpdateReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Ïã†Í≥† Í∞ÄÎä• Ï¢ÖÎ•ò ÌïòÎÇòÎ•º ÏÉàÎ°≠Í≤å ÏÇΩÏûÖÌïúÎã§.
 * @summary Ïã†Í≥† Ï¢ÖÎ•ò ÏÇΩÏûÖ
 */
export const insertBlameType1 = (blameTypeReq: BlameTypeReq, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<InsertBlameType1200>(
    { url: `/api/blame/type`, method: "post", headers: { "Content-Type": "application/json" }, data: blameTypeReq },
    options
  );
};

export type InsertBlameType1MutationResult = NonNullable<Awaited<ReturnType<typeof insertBlameType1>>>;
export type InsertBlameType1MutationBody = BlameTypeReq;
export type InsertBlameType1MutationError = ErrorType<unknown>;

export const useInsertBlameType1 = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof insertBlameType1>>, TError, { data: BlameTypeReq }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof insertBlameType1>>, { data: BlameTypeReq }> = (
    props
  ) => {
    const { data } = props ?? {};

    return insertBlameType1(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof insertBlameType1>>, TError, { data: BlameTypeReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * ÏïåÎ¶º ÌôïÏù∏ Ïãú, ÏïåÎ¶ºÏ≤¥ÌÅ¨ ÌÖåÏù¥Î∏îÏóê Îì±Î°ù
 * @summary ÏïåÎ¶º ÌôïÏù∏
 */
export const insertAlarmChk = (
  alarmId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<InsertAlarmChk200>({ url: `/api/alarm/${alarmId}`, method: "get", signal }, options);
};

export const getInsertAlarmChkQueryKey = (alarmId: number) => [`/api/alarm/${alarmId}`];

export type InsertAlarmChkInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof insertAlarmChk>>>;
export type InsertAlarmChkInfiniteQueryError = ErrorType<unknown>;

export const useInsertAlarmChkInfinite = <
  TData = Awaited<ReturnType<typeof insertAlarmChk>>,
  TError = ErrorType<unknown>
>(
  alarmId: number,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof insertAlarmChk>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getInsertAlarmChkQueryKey(alarmId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof insertAlarmChk>>> = ({ signal }) =>
    insertAlarmChk(alarmId, requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof insertAlarmChk>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!alarmId,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type InsertAlarmChkQueryResult = NonNullable<Awaited<ReturnType<typeof insertAlarmChk>>>;
export type InsertAlarmChkQueryError = ErrorType<unknown>;

export const useInsertAlarmChk = <TData = Awaited<ReturnType<typeof insertAlarmChk>>, TError = ErrorType<unknown>>(
  alarmId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof insertAlarmChk>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getInsertAlarmChkQueryKey(alarmId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof insertAlarmChk>>> = ({ signal }) =>
    insertAlarmChk(alarmId, requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof insertAlarmChk>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!alarmId,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Í¥ÄÎ¶¨Ïûê -> Ï†ÑÏ≤¥ ÏïåÎ¶º ÏÇ≠Ï†ú
 * @summary Ï†ÑÏ≤¥ ÏïåÎ¶º ÏÇ≠Ï†ú
 */
export const deleteAlarm = (alarmId: number, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<DeleteAlarm200>({ url: `/api/alarm/${alarmId}`, method: "put" }, options);
};

export type DeleteAlarmMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAlarm>>>;

export type DeleteAlarmMutationError = ErrorType<unknown>;

export const useDeleteAlarm = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteAlarm>>, TError, { alarmId: number }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAlarm>>, { alarmId: number }> = (props) => {
    const { alarmId } = props ?? {};

    return deleteAlarm(alarmId, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof deleteAlarm>>, TError, { alarmId: number }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Í¥ÄÎ¶¨Ïûê -> Ï†ÑÏ≤¥ ÏïåÎ¶º ÏàòÏ†ï
 * @summary Ï†ÑÏ≤¥ ÏïåÎ¶º ÏàòÏ†ï
 */
export const updateAlarm = (alarmUdtReq: AlarmUdtReq, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<UpdateAlarm200>(
    { url: `/api/alarm/content`, method: "put", headers: { "Content-Type": "application/json" }, data: alarmUdtReq },
    options
  );
};

export type UpdateAlarmMutationResult = NonNullable<Awaited<ReturnType<typeof updateAlarm>>>;
export type UpdateAlarmMutationBody = AlarmUdtReq;
export type UpdateAlarmMutationError = ErrorType<unknown>;

export const useUpdateAlarm = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateAlarm>>, TError, { data: AlarmUdtReq }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAlarm>>, { data: AlarmUdtReq }> = (props) => {
    const { data } = props ?? {};

    return updateAlarm(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof updateAlarm>>, TError, { data: AlarmUdtReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Oauth Ïù∏Ï¶ù ÌõÑ ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ(mbti, ÎãâÎÑ§ÏûÑ, ÎÇòÏù¥, ÏÑ±Î≥Ñ) ÏÑ§Ï†ï
 * @summary ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ Ï¥àÍ∏∞Ìôî
 */
export const setUser = (profileReq: ProfileReq, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<UserRes>(
    {
      url: `/api/users/set-profile`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: profileReq
    },
    options
  );
};

export type SetUserMutationResult = NonNullable<Awaited<ReturnType<typeof setUser>>>;
export type SetUserMutationBody = ProfileReq;
export type SetUserMutationError = ErrorType<unknown>;

export const useSetUser = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof setUser>>, TError, { data: ProfileReq }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof setUser>>, { data: ProfileReq }> = (props) => {
    const { data } = props ?? {};

    return setUser(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof setUser>>, TError, { data: ProfileReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * @summary ÌÜ†ÌÅ∞Í∏∞Î∞ò Oauth2Ïù∏Ï¶ù
 */
export const getUserByToken = (oauth2Req: Oauth2Req, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<Oauth2Res>(
    { url: `/api/users/oauth2`, method: "post", headers: { "Content-Type": "application/json" }, data: oauth2Req },
    options
  );
};

export type GetUserByTokenMutationResult = NonNullable<Awaited<ReturnType<typeof getUserByToken>>>;
export type GetUserByTokenMutationBody = Oauth2Req;
export type GetUserByTokenMutationError = ErrorType<unknown>;

export const useGetUserByToken = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof getUserByToken>>, TError, { data: Oauth2Req }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getUserByToken>>, { data: Oauth2Req }> = (props) => {
    const { data } = props ?? {};

    return getUserByToken(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof getUserByToken>>, TError, { data: Oauth2Req }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * @summary Î°úÍ∑∏Ïù∏
 */
export const login = (loginReq: LoginReq, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<UserRes>(
    { url: `/api/users/login`, method: "post", headers: { "Content-Type": "application/json" }, data: loginReq },
    options
  );
};

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>;
export type LoginMutationBody = LoginReq;
export type LoginMutationError = ErrorType<unknown>;

export const useLogin = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: LoginReq }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, { data: LoginReq }> = (props) => {
    const { data } = props ?? {};

    return login(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof login>>, TError, { data: LoginReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * @summary Î¨¥Ìïú Î°úÍ∑∏Ïù∏
 */
export const infiniteLogin = (loginReq: LoginReq, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<UserRes>(
    {
      url: `/api/users/login/infinite`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: loginReq
    },
    options
  );
};

export type InfiniteLoginMutationResult = NonNullable<Awaited<ReturnType<typeof infiniteLogin>>>;
export type InfiniteLoginMutationBody = LoginReq;
export type InfiniteLoginMutationError = ErrorType<unknown>;

export const useInfiniteLogin = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof infiniteLogin>>, TError, { data: LoginReq }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof infiniteLogin>>, { data: LoginReq }> = (props) => {
    const { data } = props ?? {};

    return infiniteLogin(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof infiniteLogin>>, TError, { data: LoginReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * @summary ÌöåÏõêÍ∞ÄÏûÖ
 */
export const join = (joinReq: JoinReq, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<JoinRes>(
    { url: `/api/users/join`, method: "post", headers: { "Content-Type": "application/json" }, data: joinReq },
    options
  );
};

export type JoinMutationResult = NonNullable<Awaited<ReturnType<typeof join>>>;
export type JoinMutationBody = JoinReq;
export type JoinMutationError = ErrorType<unknown>;

export const useJoin = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof join>>, TError, { data: JoinReq }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof join>>, { data: JoinReq }> = (props) => {
    const { data } = props ?? {};

    return join(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof join>>, TError, { data: JoinReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * ÎåìÍ∏Ä Ï¢ãÏïÑÏöî
 * @summary ÎåìÍ∏Ä Ï¢ãÏïÑÏöî
 */
export const commentLike = (
  commentLikeRequest: CommentLikeRequest,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<CommentLikeResponse>(
    {
      url: `/api/like/comment`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: commentLikeRequest
    },
    options
  );
};

export type CommentLikeMutationResult = NonNullable<Awaited<ReturnType<typeof commentLike>>>;
export type CommentLikeMutationBody = CommentLikeRequest;
export type CommentLikeMutationError = ErrorType<unknown>;

export const useCommentLike = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof commentLike>>,
    TError,
    { data: CommentLikeRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof commentLike>>, { data: CommentLikeRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return commentLike(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof commentLike>>, TError, { data: CommentLikeRequest }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Í≤åÏãúÍ∏Ä Ï¢ãÏïÑÏöî
 * @summary Í≤åÏãúÍ∏Ä Ï¢ãÏïÑÏöî
 */
export const boardLike = (boardLikeRequest: BoardLikeRequest, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<BoardLikeResponse>(
    { url: `/api/like/board`, method: "post", headers: { "Content-Type": "application/json" }, data: boardLikeRequest },
    options
  );
};

export type BoardLikeMutationResult = NonNullable<Awaited<ReturnType<typeof boardLike>>>;
export type BoardLikeMutationBody = BoardLikeRequest;
export type BoardLikeMutationError = ErrorType<unknown>;

export const useBoardLike = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof boardLike>>, TError, { data: BoardLikeRequest }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof boardLike>>, { data: BoardLikeRequest }> = (props) => {
    const { data } = props ?? {};

    return boardLike(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof boardLike>>, TError, { data: BoardLikeRequest }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Î∂ÄÏ†ÅÏ†àÌïú Í∏ÄÏù¥ÎÇò ÎåìÍ∏ÄÏùÑ Ïã†Í≥†Ìï† Îïå ÏÇ¨Ïö©ÌïúÎã§.
 * @summary Ïã†Í≥†ÌïòÍ∏∞
 */
export const blame = (blameReq: BlameReq, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<Blame200>(
    { url: `/api/blame`, method: "post", headers: { "Content-Type": "application/json" }, data: blameReq },
    options
  );
};

export type BlameMutationResult = NonNullable<Awaited<ReturnType<typeof blame>>>;
export type BlameMutationBody = BlameReq;
export type BlameMutationError = ErrorType<unknown>;

export const useBlame = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof blame>>, TError, { data: BlameReq }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof blame>>, { data: BlameReq }> = (props) => {
    const { data } = props ?? {};

    return blame(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof blame>>, TError, { data: BlameReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Î∞∏Îü∞Ïä§ Í≤åÏûÑ 10Í∞úÎ•º Î∞õÏïÑÏò®Îã§.
 * @summary Î∞∏Îü∞Ïä§Í≤åÏûÑ ÏµúÏã†Ïàú 10Í∞ú Ï°∞Ìöå
 */
export const getAllBalance = (options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
  return customInstance<GetAllBalanceRes>({ url: `/api/balances`, method: "get", signal }, options);
};

export const getGetAllBalanceQueryKey = () => [`/api/balances`];

export type GetAllBalanceInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllBalance>>>;
export type GetAllBalanceInfiniteQueryError = ErrorType<unknown>;

export const useGetAllBalanceInfinite = <
  TData = Awaited<ReturnType<typeof getAllBalance>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllBalance>>, TError, TData>;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllBalanceQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllBalance>>> = ({ signal }) =>
    getAllBalance(requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getAllBalance>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetAllBalanceQueryResult = NonNullable<Awaited<ReturnType<typeof getAllBalance>>>;
export type GetAllBalanceQueryError = ErrorType<unknown>;

export const useGetAllBalance = <
  TData = Awaited<ReturnType<typeof getAllBalance>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getAllBalance>>, TError, TData>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllBalanceQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllBalance>>> = ({ signal }) =>
    getAllBalance(requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof getAllBalance>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Î∞∏Îü∞Ïä§ Í≤åÏûÑÏùÑ Îì±Î°ùÌïúÎã§.
 * @summary [admin] Î∞∏Îü∞Ïä§Í≤åÏûÑ Îì±Î°ù
 */
export const insertBalance = (insertBalanceReq: InsertBalanceReq, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<InsertBalance200>(
    { url: `/api/balances`, method: "post", headers: { "Content-Type": "application/json" }, data: insertBalanceReq },
    options
  );
};

export type InsertBalanceMutationResult = NonNullable<Awaited<ReturnType<typeof insertBalance>>>;
export type InsertBalanceMutationBody = InsertBalanceReq;
export type InsertBalanceMutationError = ErrorType<unknown>;

export const useInsertBalance = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof insertBalance>>,
    TError,
    { data: InsertBalanceReq },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof insertBalance>>, { data: InsertBalanceReq }> = (
    props
  ) => {
    const { data } = props ?? {};

    return insertBalance(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof insertBalance>>, TError, { data: InsertBalanceReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Î∞∏Îü∞Ïä§ Í≤åÏûÑÏóê Ìà¨ÌëúÌïúÎã§.
 * @summary Î∞∏Îü∞Ïä§ Í≤åÏûÑ Ìà¨Ìëú
 */
export const voteBalanceGame = (voteBalanceReq: VoteBalanceReq, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<VoteBalanceGame200>(
    {
      url: `/api/balances/vote`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: voteBalanceReq
    },
    options
  );
};

export type VoteBalanceGameMutationResult = NonNullable<Awaited<ReturnType<typeof voteBalanceGame>>>;
export type VoteBalanceGameMutationBody = VoteBalanceReq;
export type VoteBalanceGameMutationError = ErrorType<unknown>;

export const useVoteBalanceGame = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof voteBalanceGame>>,
    TError,
    { data: VoteBalanceReq },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof voteBalanceGame>>, { data: VoteBalanceReq }> = (
    props
  ) => {
    const { data } = props ?? {};

    return voteBalanceGame(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof voteBalanceGame>>, TError, { data: VoteBalanceReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Ï†ÑÏ≤¥ ÏïåÎ¶º Î∞è Í∞úÎ≥Ñ ÏïåÎ¶º Îì±Î°ù
 * @summary Ï†ÑÏ≤¥ ÏïåÎ¶º Îì±Î°ù
 */
export const insertAlarm = (alarmReq: AlarmReq, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<InsertAlarm200>(
    { url: `/api/alarm`, method: "post", headers: { "Content-Type": "application/json" }, data: alarmReq },
    options
  );
};

export type InsertAlarmMutationResult = NonNullable<Awaited<ReturnType<typeof insertAlarm>>>;
export type InsertAlarmMutationBody = AlarmReq;
export type InsertAlarmMutationError = ErrorType<unknown>;

export const useInsertAlarm = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof insertAlarm>>, TError, { data: AlarmReq }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof insertAlarm>>, { data: AlarmReq }> = (props) => {
    const { data } = props ?? {};

    return insertAlarm(data, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof insertAlarm>>, TError, { data: AlarmReq }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * @summary idÎ°ú Ïú†Ï†Ä Í≤ÄÏÉâ
 */
export const getUserById = (userId: number, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
  return customInstance<UserRes>({ url: `/api/users/${userId}`, method: "get", signal }, options);
};

export const getGetUserByIdQueryKey = (userId: number) => [`/api/users/${userId}`];

export type GetUserByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>;
export type GetUserByIdInfiniteQueryError = ErrorType<unknown>;

export const useGetUserByIdInfinite = <TData = Awaited<ReturnType<typeof getUserById>>, TError = ErrorType<unknown>>(
  userId: number,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserByIdQueryKey(userId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) =>
    getUserById(userId, requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getUserById>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetUserByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>;
export type GetUserByIdQueryError = ErrorType<unknown>;

export const useGetUserById = <TData = Awaited<ReturnType<typeof getUserById>>, TError = ErrorType<unknown>>(
  userId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserByIdQueryKey(userId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) =>
    getUserById(userId, requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof getUserById>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ÏÇ¨Ïö©Ïûê ÎãâÎÑ§ÏûÑ Ï§ëÎ≥µ ÌôïÏù∏
 */
export const checkUserNickName = (
  nickName: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<boolean>({ url: `/api/users/${nickName}/nickname-exists`, method: "get", signal }, options);
};

export const getCheckUserNickNameQueryKey = (nickName: string) => [`/api/users/${nickName}/nickname-exists`];

export type CheckUserNickNameInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof checkUserNickName>>>;
export type CheckUserNickNameInfiniteQueryError = ErrorType<unknown>;

export const useCheckUserNickNameInfinite = <
  TData = Awaited<ReturnType<typeof checkUserNickName>>,
  TError = ErrorType<unknown>
>(
  nickName: string,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkUserNickName>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCheckUserNickNameQueryKey(nickName);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof checkUserNickName>>> = ({ signal }) =>
    checkUserNickName(nickName, requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof checkUserNickName>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!nickName,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type CheckUserNickNameQueryResult = NonNullable<Awaited<ReturnType<typeof checkUserNickName>>>;
export type CheckUserNickNameQueryError = ErrorType<unknown>;

export const useCheckUserNickName = <
  TData = Awaited<ReturnType<typeof checkUserNickName>>,
  TError = ErrorType<unknown>
>(
  nickName: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof checkUserNickName>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCheckUserNickNameQueryKey(nickName);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof checkUserNickName>>> = ({ signal }) =>
    checkUserNickName(nickName, requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof checkUserNickName>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!nickName,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * ÏÇ¨Ïö©Ïûê ÏûêÏã†Ïùò Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò®Îã§
 * @summary ÏûêÏã†Ïùò Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò¥
 */
export const getUserSelf = (options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
  return customInstance<UserSelfRes>({ url: `/api/users/me`, method: "get", signal }, options);
};

export const getGetUserSelfQueryKey = () => [`/api/users/me`];

export type GetUserSelfInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserSelf>>>;
export type GetUserSelfInfiniteQueryError = ErrorType<unknown>;

export const useGetUserSelfInfinite = <
  TData = Awaited<ReturnType<typeof getUserSelf>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserSelf>>, TError, TData>;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserSelfQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserSelf>>> = ({ signal }) =>
    getUserSelf(requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getUserSelf>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetUserSelfQueryResult = NonNullable<Awaited<ReturnType<typeof getUserSelf>>>;
export type GetUserSelfQueryError = ErrorType<unknown>;

export const useGetUserSelf = <TData = Awaited<ReturnType<typeof getUserSelf>>, TError = ErrorType<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getUserSelf>>, TError, TData>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserSelfQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserSelf>>> = ({ signal }) =>
    getUserSelf(requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof getUserSelf>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * ÏõêÌïòÎäî ÏøºÎ¶¨, Î∂ÑÎ•òÎ•º ÌÜµÌï¥ Í≤ÄÏÉâÌïúÎã§.http://localhost:8080/api/search?page=0&size=10&sort=id,DESC&query=sendowl&type=title
 * @summary Í≤ÄÏÉâ Ï°∞Ìöå
 */
export const boards = (
  params: BoardsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<BoardsRes>({ url: `/api/search`, method: "get", params, signal }, options);
};

export const getBoardsQueryKey = (params: BoardsParams) => [`/api/search`, ...(params ? [params] : [])];

export type BoardsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof boards>>>;
export type BoardsInfiniteQueryError = ErrorType<unknown>;

export const useBoardsInfinite = <TData = Awaited<ReturnType<typeof boards>>, TError = ErrorType<unknown>>(
  params: BoardsParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof boards>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBoardsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof boards>>> = ({ signal }) =>
    boards(params, requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof boards>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type BoardsQueryResult = NonNullable<Awaited<ReturnType<typeof boards>>>;
export type BoardsQueryError = ErrorType<unknown>;

export const useBoards = <TData = Awaited<ReturnType<typeof boards>>, TError = ErrorType<unknown>>(
  params: BoardsParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof boards>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBoardsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof boards>>> = ({ signal }) =>
    boards(params, requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof boards>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Î™®Îì† Ïú†Ï†ÄÎì§Ïùò mbti ÏàòÎ•º Î∞òÌôòÌïúÎã§.
 * @summary Ïú†Ï†ÄÎì§Ïùò mbti Ï°∞Ìöå
 */
export const getUserMbti = (options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
  return customInstance<UserMbti[]>({ url: `/api/mbti/users`, method: "get", signal }, options);
};

export const getGetUserMbtiQueryKey = () => [`/api/mbti/users`];

export type GetUserMbtiInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserMbti>>>;
export type GetUserMbtiInfiniteQueryError = ErrorType<unknown>;

export const useGetUserMbtiInfinite = <
  TData = Awaited<ReturnType<typeof getUserMbti>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserMbti>>, TError, TData>;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserMbtiQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserMbti>>> = ({ signal }) =>
    getUserMbti(requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getUserMbti>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetUserMbtiQueryResult = NonNullable<Awaited<ReturnType<typeof getUserMbti>>>;
export type GetUserMbtiQueryError = ErrorType<unknown>;

export const useGetUserMbti = <TData = Awaited<ReturnType<typeof getUserMbti>>, TError = ErrorType<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getUserMbti>>, TError, TData>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserMbtiQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserMbti>>> = ({ signal }) =>
    getUserMbti(requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof getUserMbti>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Ïπ¥ÌÖåÍ≥†Î¶¨idÎ•º ÌÜµÌï¥ Ìï¥Îãπ Ïπ¥ÌÖåÍ≥†Î¶¨Ïóê Í≤åÏãúÍ∏ÄÏùÑ Ïì¥ Ïú†Ï†ÄÎì§Ïùò mbti ÏàúÏúÑ(Ïú†Ï†ÄÏàò)Î•º Î∞òÌôòÌïúÎã§.
 * @summary Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò Ïú†Ï†Ä mbti Ï°∞Ìöå.
 */
export const getUserMbtiFromCategory = (
  categoryId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<UserMbti[]>({ url: `/api/mbti/category/${categoryId}`, method: "get", signal }, options);
};

export const getGetUserMbtiFromCategoryQueryKey = (categoryId: number) => [`/api/mbti/category/${categoryId}`];

export type GetUserMbtiFromCategoryInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserMbtiFromCategory>>
>;
export type GetUserMbtiFromCategoryInfiniteQueryError = ErrorType<unknown>;

export const useGetUserMbtiFromCategoryInfinite = <
  TData = Awaited<ReturnType<typeof getUserMbtiFromCategory>>,
  TError = ErrorType<unknown>
>(
  categoryId: number,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserMbtiFromCategory>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserMbtiFromCategoryQueryKey(categoryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserMbtiFromCategory>>> = ({ signal }) =>
    getUserMbtiFromCategory(categoryId, requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getUserMbtiFromCategory>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!categoryId,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetUserMbtiFromCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getUserMbtiFromCategory>>>;
export type GetUserMbtiFromCategoryQueryError = ErrorType<unknown>;

export const useGetUserMbtiFromCategory = <
  TData = Awaited<ReturnType<typeof getUserMbtiFromCategory>>,
  TError = ErrorType<unknown>
>(
  categoryId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getUserMbtiFromCategory>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserMbtiFromCategoryQueryKey(categoryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserMbtiFromCategory>>> = ({ signal }) =>
    getUserMbtiFromCategory(categoryId, requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof getUserMbtiFromCategory>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!categoryId,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Í≤åÏãúÍ∏ÄÏùò idÎ•º ÌÜµÌï¥ Î≤†Ïä§Ìä∏ ÎåìÍ∏Ä Î™©Î°ùÏùÑ Í∞ÄÏ†∏Ïò®Îã§.
 * @summary Î≤†Ïä§Ìä∏ ÎåìÍ∏Ä Î™©Î°ù Ï°∞Ìöå
 */
export const getCommentList1 = (
  params: GetCommentList1Params,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GetCommentList1200>({ url: `/api/comments/best`, method: "get", params, signal }, options);
};

export const getGetCommentList1QueryKey = (params: GetCommentList1Params) => [
  `/api/comments/best`,
  ...(params ? [params] : [])
];

export type GetCommentList1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCommentList1>>>;
export type GetCommentList1InfiniteQueryError = ErrorType<unknown>;

export const useGetCommentList1Infinite = <
  TData = Awaited<ReturnType<typeof getCommentList1>>,
  TError = ErrorType<unknown>
>(
  params: GetCommentList1Params,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCommentList1>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCommentList1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCommentList1>>> = ({ signal }) =>
    getCommentList1(params, requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getCommentList1>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetCommentList1QueryResult = NonNullable<Awaited<ReturnType<typeof getCommentList1>>>;
export type GetCommentList1QueryError = ErrorType<unknown>;

export const useGetCommentList1 = <TData = Awaited<ReturnType<typeof getCommentList1>>, TError = ErrorType<unknown>>(
  params: GetCommentList1Params,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getCommentList1>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCommentList1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCommentList1>>> = ({ signal }) =>
    getCommentList1(params, requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof getCommentList1>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò Ïπ¥Ïö¥Ìä∏(Ïù∏Í∏∞ÎèÑ)ÏàúÏúºÎ°ú Î∞òÌôòÌïúÎã§. Ï°∞Ïù∏ÏùÑ ÌïòÍ∏∞ ÎïåÎ¨∏Ïóê ÏùºÎ∞ò Î¶¨Ïä§Ìä∏ Î∞òÌôòÎ≥¥Îã§ Ï°∞Í∏à ÎäêÎ¶º
 * @summary Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò Ïπ¥Ïö¥Ìä∏(Ïù∏Í∏∞ÎèÑ)ÏàúÏúºÎ°ú Ï°∞Ìöå
 */
export const categoriesCount = (options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
  return customInstance<CategoriesCount200>({ url: `/api/categories/popular`, method: "get", signal }, options);
};

export const getCategoriesCountQueryKey = () => [`/api/categories/popular`];

export type CategoriesCountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof categoriesCount>>>;
export type CategoriesCountInfiniteQueryError = ErrorType<unknown>;

export const useCategoriesCountInfinite = <
  TData = Awaited<ReturnType<typeof categoriesCount>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof categoriesCount>>, TError, TData>;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCategoriesCountQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof categoriesCount>>> = ({ signal }) =>
    categoriesCount(requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof categoriesCount>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type CategoriesCountQueryResult = NonNullable<Awaited<ReturnType<typeof categoriesCount>>>;
export type CategoriesCountQueryError = ErrorType<unknown>;

export const useCategoriesCount = <
  TData = Awaited<ReturnType<typeof categoriesCount>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof categoriesCount>>, TError, TData>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCategoriesCountQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof categoriesCount>>> = ({ signal }) =>
    categoriesCount(requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof categoriesCount>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Í≤åÏãúÍ∏ÄÏùÑ ÏÉÅÏÑ∏ Ï°∞ÌöåÌïúÎã§.
 * @summary Í≤åÏãúÍ∏Ä ÏÉÅÏÑ∏ Ï°∞Ìöå
 */
export const boardDetail = (
  boardId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<BoardDetail200>({ url: `/api/boards/${boardId}`, method: "get", signal }, options);
};

export const getBoardDetailQueryKey = (boardId: number) => [`/api/boards/${boardId}`];

export type BoardDetailInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof boardDetail>>>;
export type BoardDetailInfiniteQueryError = ErrorType<unknown>;

export const useBoardDetailInfinite = <TData = Awaited<ReturnType<typeof boardDetail>>, TError = ErrorType<unknown>>(
  boardId: number,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof boardDetail>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBoardDetailQueryKey(boardId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof boardDetail>>> = ({ signal }) =>
    boardDetail(boardId, requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof boardDetail>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!boardId,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type BoardDetailQueryResult = NonNullable<Awaited<ReturnType<typeof boardDetail>>>;
export type BoardDetailQueryError = ErrorType<unknown>;

export const useBoardDetail = <TData = Awaited<ReturnType<typeof boardDetail>>, TError = ErrorType<unknown>>(
  boardId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof boardDetail>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBoardDetailQueryKey(boardId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof boardDetail>>> = ({ signal }) =>
    boardDetail(boardId, requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof boardDetail>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!boardId,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Í≤åÏãúÍ∏ÄÏùÑ ÏÜåÌîÑÌä∏ ÏÇ≠Ï†úÌïúÎã§.
 * @summary Í≤åÏãúÍ∏Ä ÏÜåÌîÑÌä∏ ÏÇ≠Ï†ú
 */
export const boardDelete = (boardId: number, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<BoardDelete200>({ url: `/api/boards/${boardId}`, method: "delete" }, options);
};

export type BoardDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof boardDelete>>>;

export type BoardDeleteMutationError = ErrorType<unknown>;

export const useBoardDelete = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof boardDelete>>, TError, { boardId: number }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof boardDelete>>, { boardId: number }> = (props) => {
    const { boardId } = props ?? {};

    return boardDelete(boardId, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof boardDelete>>, TError, { boardId: number }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Ï°∞Í±¥Ïóê Îî∞Îùº ÎØ∏Î¶¨Î≥¥Í∏∞ Í≤åÏãúÍ∏ÄÏùÑ Ï°∞ÌöåÌïúÎã§.
 * @summary ÎØ∏Î¶¨Î≥¥Í∏∞ Í≤åÏãúÍ∏Ä Î™©Î°ù Ï°∞Ìöå
 */
export const getPreviewBoards = (
  params: GetPreviewBoardsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GetPreviewBoards200>({ url: `/api/boards/preview`, method: "get", params, signal }, options);
};

export const getGetPreviewBoardsQueryKey = (params: GetPreviewBoardsParams) => [
  `/api/boards/preview`,
  ...(params ? [params] : [])
];

export type GetPreviewBoardsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPreviewBoards>>>;
export type GetPreviewBoardsInfiniteQueryError = ErrorType<unknown>;

export const useGetPreviewBoardsInfinite = <
  TData = Awaited<ReturnType<typeof getPreviewBoards>>,
  TError = ErrorType<unknown>
>(
  params: GetPreviewBoardsParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPreviewBoards>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPreviewBoardsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPreviewBoards>>> = ({ signal }) =>
    getPreviewBoards(params, requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getPreviewBoards>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetPreviewBoardsQueryResult = NonNullable<Awaited<ReturnType<typeof getPreviewBoards>>>;
export type GetPreviewBoardsQueryError = ErrorType<unknown>;

export const useGetPreviewBoards = <TData = Awaited<ReturnType<typeof getPreviewBoards>>, TError = ErrorType<unknown>>(
  params: GetPreviewBoardsParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getPreviewBoards>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPreviewBoardsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPreviewBoards>>> = ({ signal }) =>
    getPreviewBoards(params, requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof getPreviewBoards>>, TError, TData>({
    queryKey,
    queryFn,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * ÌïòÎÇòÏùò Î∞∏Îü∞Ïä§ Í≤åÏûÑÏùò Îç∞Ïù¥ÌÑ∞Î•º ÏûêÏÑ∏Ìûà Î∞õÏïÑÏò®Îã§.
 * @summary Î∞∏Îü∞Ïä§ Í≤åÏûÑ ÏûêÏÑ∏Ìûà Ï°∞Ìöå
 */
export const getDetailBalance = (
  balanceId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<BalanceRes>({ url: `/api/balances/${balanceId}`, method: "get", signal }, options);
};

export const getGetDetailBalanceQueryKey = (balanceId: number) => [`/api/balances/${balanceId}`];

export type GetDetailBalanceInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDetailBalance>>>;
export type GetDetailBalanceInfiniteQueryError = ErrorType<unknown>;

export const useGetDetailBalanceInfinite = <
  TData = Awaited<ReturnType<typeof getDetailBalance>>,
  TError = ErrorType<unknown>
>(
  balanceId: number,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDetailBalance>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDetailBalanceQueryKey(balanceId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDetailBalance>>> = ({ signal }) =>
    getDetailBalance(balanceId, requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getDetailBalance>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!balanceId,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetDetailBalanceQueryResult = NonNullable<Awaited<ReturnType<typeof getDetailBalance>>>;
export type GetDetailBalanceQueryError = ErrorType<unknown>;

export const useGetDetailBalance = <TData = Awaited<ReturnType<typeof getDetailBalance>>, TError = ErrorType<unknown>>(
  balanceId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getDetailBalance>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDetailBalanceQueryKey(balanceId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDetailBalance>>> = ({ signal }) =>
    getDetailBalance(balanceId, requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof getDetailBalance>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!balanceId,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Î∞∏Îü∞Ïä§ Í≤åÏûÑÏùÑ ÏÜåÌîÑÌä∏ ÏÇ≠Ï†úÌïúÎã§.
 * @summary [admin] Î∞∏Îü∞Ïä§Í≤åÏûÑ ÏÇ≠Ï†ú
 */
export const deleteBalance = (balanceId: number, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<DeleteBalance200>({ url: `/api/balances/${balanceId}`, method: "delete" }, options);
};

export type DeleteBalanceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBalance>>>;

export type DeleteBalanceMutationError = ErrorType<unknown>;

export const useDeleteBalance = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteBalance>>, TError, { balanceId: number }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBalance>>, { balanceId: number }> = (props) => {
    const { balanceId } = props ?? {};

    return deleteBalance(balanceId, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof deleteBalance>>, TError, { balanceId: number }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * ÌäπÏ†ï Î∞∏Îü∞Ïä§ Í≤åÏûÑÏóê ÎåÄÌï¥ ÌäπÏ†ï ÏÇ¨Ïö©ÏûêÍ∞Ä Ïñ¥ÎîîÏóê Ï∞∏Ïó¨ÌñàÎäîÏßÄ ÌôïÏù∏ÌïúÎã§.
 * @summary ÏÇ¨Ïö©Ïûê Î∞∏Îü∞Ïä§ Í≤åÏûÑ Ï∞∏Ïó¨ Ïó¨Î∂Ä Ï°∞Ìöå
 */
export const getWhereUserVote = (
  balanceId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GetWhereUserVote200>(
    { url: `/api/balances/vote/${balanceId}`, method: "get", signal },
    options
  );
};

export const getGetWhereUserVoteQueryKey = (balanceId: number) => [`/api/balances/vote/${balanceId}`];

export type GetWhereUserVoteInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWhereUserVote>>>;
export type GetWhereUserVoteInfiniteQueryError = ErrorType<unknown>;

export const useGetWhereUserVoteInfinite = <
  TData = Awaited<ReturnType<typeof getWhereUserVote>>,
  TError = ErrorType<unknown>
>(
  balanceId: number,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWhereUserVote>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWhereUserVoteQueryKey(balanceId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWhereUserVote>>> = ({ signal }) =>
    getWhereUserVote(balanceId, requestOptions, signal);

  const query = useInfiniteQuery<Awaited<ReturnType<typeof getWhereUserVote>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!balanceId,
    ...queryOptions
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export type GetWhereUserVoteQueryResult = NonNullable<Awaited<ReturnType<typeof getWhereUserVote>>>;
export type GetWhereUserVoteQueryError = ErrorType<unknown>;

export const useGetWhereUserVote = <TData = Awaited<ReturnType<typeof getWhereUserVote>>, TError = ErrorType<unknown>>(
  balanceId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getWhereUserVote>>, TError, TData>;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWhereUserVoteQueryKey(balanceId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWhereUserVote>>> = ({ signal }) =>
    getWhereUserVote(balanceId, requestOptions, signal);

  const query = useQuery<Awaited<ReturnType<typeof getWhereUserVote>>, TError, TData>({
    queryKey,
    queryFn,
    enabled: !!balanceId,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * ÎåìÍ∏Ä Ï¢ãÏïÑÏöî Ï∑®ÏÜå
 * @summary ÎåìÍ∏Ä Ï¢ãÏïÑÏöî Ï∑®ÏÜå
 */
export const commentUnLike = (commentId: number, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<boolean>({ url: `/api/like/comment/${commentId}`, method: "delete" }, options);
};

export type CommentUnLikeMutationResult = NonNullable<Awaited<ReturnType<typeof commentUnLike>>>;

export type CommentUnLikeMutationError = ErrorType<unknown>;

export const useCommentUnLike = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof commentUnLike>>, TError, { commentId: number }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof commentUnLike>>, { commentId: number }> = (props) => {
    const { commentId } = props ?? {};

    return commentUnLike(commentId, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof commentUnLike>>, TError, { commentId: number }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Í≤åÏãúÍ∏Ä Ï¢ãÏïÑÏöî Ï∑®ÏÜå
 * @summary Í≤åÏãúÍ∏Ä Ï¢ãÏïÑÏöî Ï∑®ÏÜå
 */
export const boardUnLike = (boardId: number, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<boolean>({ url: `/api/like/board/${boardId}`, method: "delete" }, options);
};

export type BoardUnLikeMutationResult = NonNullable<Awaited<ReturnType<typeof boardUnLike>>>;

export type BoardUnLikeMutationError = ErrorType<unknown>;

export const useBoardUnLike = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof boardUnLike>>, TError, { boardId: number }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof boardUnLike>>, { boardId: number }> = (props) => {
    const { boardId } = props ?? {};

    return boardUnLike(boardId, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof boardUnLike>>, TError, { boardId: number }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * ÎåìÍ∏ÄÏùÑ ÏÜåÌîÑÌä∏ ÏÇ≠Ï†úÌïúÎã§.
 * @summary ÎåìÍ∏Ä ÏÜåÌîÑÌä∏ ÏÇ≠Ï†ú
 */
export const deleteComment = (commentId: number, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<DeleteComment200>({ url: `/api/comments/${commentId}`, method: "delete" }, options);
};

export type DeleteCommentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteComment>>>;

export type DeleteCommentMutationError = ErrorType<unknown>;

export const useDeleteComment = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteComment>>, TError, { commentId: number }, TContext>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteComment>>, { commentId: number }> = (props) => {
    const { commentId } = props ?? {};

    return deleteComment(commentId, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof deleteComment>>, TError, { commentId: number }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Ïã†Í≥† Í∞ÄÎä•Ìïú Ï¢ÖÎ•ò Ï§ë ÌïòÎÇòÎ•º ÏÇ≠Ï†úÌïúÎã§.
 * @summary Ïã†Í≥† Ï¢ÖÎ•ò Ï†úÍ±∞
 */
export const insertBlameType2 = (blameTypeId: number, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<InsertBlameType2200>({ url: `/api/blame/type/${blameTypeId}`, method: "delete" }, options);
};

export type InsertBlameType2MutationResult = NonNullable<Awaited<ReturnType<typeof insertBlameType2>>>;

export type InsertBlameType2MutationError = ErrorType<unknown>;

export const useInsertBlameType2 = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof insertBlameType2>>,
    TError,
    { blameTypeId: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof insertBlameType2>>, { blameTypeId: number }> = (
    props
  ) => {
    const { blameTypeId } = props ?? {};

    return insertBlameType2(blameTypeId, requestOptions);
  };

  return useMutation<Awaited<ReturnType<typeof insertBlameType2>>, TError, { blameTypeId: number }, TContext>(
    mutationFn,
    mutationOptions
  );
};
